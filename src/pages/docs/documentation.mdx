---
title: Documentation
---

<DocsSidebar/>

<DocsContent>

<DocsArticle id="getting-started">

# Getting Started

<DocsSection id="install">

## Install

#### Software Requirements

`node` >= 12 (LTS only), `yarn` >= 1.20, and `docker` >= 19.

We rely on `yarn` workspaces, and `npm` does not support them yet.

Our development is mostly on Linux. Best platform for running `docker` containers.

#### Download

Clone the main repository

```shell
git clone https://github.com/cafjs/caf.git
```

Update submodules

```shell
cd caf; git submodule update --init
```

Install dependencies

```shell
yarn run installAll
```

Add to your path the `cafjs` tool binary

```shell
export PATH=<your_install_directory>/caf/bin:$PATH
```

Download the latest `docker` images

```shell
cafjs update
```

#### Test

Let's build and run locally a simple app.


```shell
cd apps/caf_helloworld; cafjs build; cafjs run helloworld
```

With `docker ps` you should see seven running containers. They simulate the support services that we run in the Cloud.

The app launcher URL is http://root-launcher.vcap.me (DNS resolves `*.vcap.me` to `127.0.0.1`, the local loop). Using your browser, login with user `foo` and password `bar`. Then, with the top left menu, click the `+` icon to add a `helloworld` app instance.

Fill the form with:

* App publisher: `root` (in local mode apps are always published by `root`)
* App name: `helloworld`
* CA name: anything containing ASCII characters and numbers.

and a `counter` example should appear. Use the `+` again to create other instances, and then switch between them with the top left menu.

To stop it, a single `Control-C` will initiate a gentle container shutdown but, for the impatient, a second `Control-C` will brute force a clean-up. Double tap.

In both cases we should be able to restart without losing the previous state, since the Redis container generates a checkpoint file in the host diretory `/tmp`. Delete this file to start from scratch:

```shell
sudo rm /tmp/redis/appendonly.aof
```

Finally, when containers hang, we can always use the nuclear cleanup option

```shell
cafjs reset
```

</DocsSection>

<DocsSection id="headless-example">

## Your First App

Let's create a simple app with no front end.

*Caf.js* is managed as a monorepo using `yarn` workspaces. Anything under the sub-directory `caf/playground/app` becomes part of the workspace, and we will create the app there.

Using a monorepo has many advantages, but the most important one is that you know what you are getting. When we create a release of *Caf.js* we freeze all our packages, and test them together. Your app will not suffer from semver mistakes due to these packages.

To create the app skeleton we use `cafjs generate`, an application template generator. The default templates are in a Docker image, and it is easy to customize and share your templates by publishing a new image. See  <Link to="#tools">Tools</Link> for details.

```shell
cd playground; rm -fr app;  cafjs generate myapp cloud ./app
```

and then install, build, and run. Install is only needed for the first build, to update dependencies in the monorepo.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

This time we used the flag `-d` to turn on debugging mode. You should see debug logs in the console. It also opens the debug port `9229`, and you can set breakpoints, and inspect variables, with the Chrome browser developer tools (`chrome://inspect`). The *Redis* instance is also accessible in host port `6380`.

There is no front end, and we use a script in the `util` directory to read state, and subscribe to notifications.

```shell
cd util; ./client.js --url http://root-myapp.vcap.me bar foo-ca1
```

What is in the box?

We will use this example to introduce *Caf.js* programming in the <Link to="#concepts">next</Link> section. Let's look at the files in the `lib` directory first:

* `rsa_pub.pem` A dummy public key to validate authentication tokens in a local deployment. When you deploy your app in the *Caf.js Cloud*, we swap this key by the "real" one.
* `framework++.json` Describes changes to the baseline platform configuration in <Link to="../../apis/#caf_platform">framework.json</Link>.
* `ca++.json` Describes changes to the baseline cloud assistant configuration in <Link to="../../apis/#caf_ca">ca.json</Link>.
* `ca_methods.js` Your code.

To understand the json files have a look at our <Link to="#components">component model</Link>. Sections <Link to="#cloud-assistant">Cloud Assistant</Link> and <Link to="#autonomous">Autonomous Computation</Link> cover `ca_methods.js`. The script is explained in the <Link to="#client">Client Library</Link>.

</DocsSection>

<DocsSection id="add-react-frontend">

## Add a React User Interface

Let's add a *React* front end to the previous app.

```shell
cd playground; rm -fr app;  cafjs generate myapp web ./app
```
and again:

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

and now, as we did for testing the <Link to="#install">installation</Link>, login with the browser, and create a few instances with app name `myapp`, and `root` publisher, since we are in local mode.

The app uses <Link to="/autonomous">Proactive Server Side Rendering (PSSR)</Link> for fast app switching. The json files add the required <Link to="../../apis/#caf_react">React plugin</Link>.  In `ca_methods.js` there is also a new method `hello()`, which provides the cache key for rendering, and a few calls to the new plugin. Without PSSR the cloud code would look similar to the previous example.

The code in `public` is mostly a standard `React` app, which uses `redux` to manage state, and `react-bootstrap` components to build the UI.

The only novelty is a session object to connect to a cloud assistant in `AppSession.js`, binding actions to remote methods in `AppActions.js`, and a custom initialization in `app.js`.

These are **not** hard dependencies. This is just an example integrating *Caf.js* with a front end, using libraries that we are familiar with. There are no *Caf.js* dependencies with `react-bootstrap`. Replacing `redux` by another state management solution just needs a simple integration with the client library, similar to `AppActions.js`. For PSSR, replacing `React` by another framework would require a new plugin though.


</DocsSection>

<DocsSection id="cafjs-cloud">

## Caf.js Cloud

If you are self-hosting your apps, skip this section.

The *Caf.js Cloud* is currently in beta, and this section is likely to change.

#### Requirements

Create a *Caf.js Cloud* account [here](https://root-launcher.cafjs.com).

Login and create an instance of the [Turtles](https://github.com/cafjs/caf_turtles.git) deployer (app publisher `root`, app name `turtles`, choose any name for your instance).

To publish a **public** `Docker` image containing your app, you need an account on a public Docker registry. For example, [Docker Hub](https://hub.docker.com),  [GitHub Container Registry](https://docs.github.com/en/packages/guides/about-github-container-registry), and [GitLab Container Registry](https://docs.gitlab.com/ee/user/packages/container_registry/), they all have free plans. We use internally the [Google Container Registry](https://cloud.google.com/container-registry).

If you do not have a registry account, but just want to try `Turtles`, the image for this example is `gcr.io/cafjs-k8/root-webexample`.

#### Deploy

Let's create an image with the previous app. Change the image name prefix to match your registry provider.

```shell
cd playground/app; cafjs mkImage . gcr.io/cafjs-k8/root-webexample
```

Ensure that it runs fine before uploading

```shell
cafjs run --appImage gcr.io/cafjs-k8/root-webexample myapp
```

and then create local instances as before.

Now we are ready to upload the image

```shell
docker push gcr.io/cafjs-k8/root-webexample
```

Login to *Caf.js Cloud* `https://root-launcher.cafjs.com` using a browser.

And then, to go live, you need to do two things:

* Register the app with the top left menu.
* Deploy with `Turtles`.

When you register this app, choose a name, a plan, and the percentage of profit that you want to make. Based on that your app gets a price in subscription-days per unit. A unit is 10 cents plus fees. See section <Link to="../../hosting">Caf.js Cloud</Link> for details.

To deploy with `Turtles` use the previous app and image names. Set `Disable CDN` to `On`, unless you have configured your own CDN in the image. You can also set environment properties for your app. We use properties to configure secrets since images are always public.

Check the status of your app (assuming your username is `antonio`, and the app name is `mycoolapp`)

```shell
curl https://antonio-mycoolapp.cafjs.com/ping
```

and monitor its performance with

```shell
curl https://antonio-mycoolapp.cafjs.com/stats
```

After a few seconds, you, and **every other user**, can create an instance of your app with the top-left menu, using your username `antonio` as publisher, and the previous app name `mycoolapp`.

And when they do, you **keep getting units** for as long as they use your app.

Maintaining a registered app costs one unit per week. Do not forget to **delete** the app with `Turtles`, **and unregister** it with the top left menu, when you are done.

With the `People` app, you can view stats for your registered apps, your active cloud assistants, or the current unit balance. You can also use this app to buy more units, or send/receive units to/from other users. This app is free and always installed.

</DocsSection>

<DocsSection id="add-device">

## Add a Simulated Device

#### Software Requirements

When *Caf.js* simulates a device, it creates images for an ARM processor, and executes ARM binaries. The goal is to be as close as possible to the real thing.

To do that, install in your Linux box the `qemu-user-static` and `binfmt` modules. For example, in Ubuntu:

```shell
sudo apt-get update && sudo apt-get install -y qemu-user-static binfmt-support
```
#### IoT Device App

Let's create an app that provides a <Link to="/permanent">permanent presence</Link> for an IoT device.

```shell
cd playground; rm -fr app;  cafjs generate myapp iot ./app
```
and then install, build, and run.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

The [Gadget](https://github.com/cafjs/caf_gadget.git) app manages IoT devices. Login with the local URL http://root-launcher.vcap.me and create a `Gadget` instance with publisher `root` and app name `gadget`. The instance name should match the name of the device, for example, `device1`.

Create an instance of `myapp` (publisher is always `root` in local deployment), ensure that the instance name matches the device name, i.e., `device1`.

Go back to the `Gadget` instance and set the app name to `root-myapp`. This app does not need privileged mode, but most do, as the pop-up warning explains. You can also set environment properties for the `node.js` process running in the device.

After `Update` you should see `Token=yes` because we created the app after the `Gadget` instance. If that is not the case, just go back to the app, and the token will transparently propagate.

Now we are ready to start the simulated device in another console. Note that the name of the device should be `device1`.

```shell
cafjs device -d foo-device1
```

The first thing the new device does is to download from its `Gadget` instance a Docker image spec for the current app. Building this ARM image takes about a minute in my laptop, but images are cached in the host, and only rebuild when the spec changes. Then, it starts the app in a container.

Since we started the app with `-d` (debug mode), you should see the debug logs in the console. If you go back to the instance of `myapp`, and click `Do it!`, you should see in the log `setPin` set to `true`, and about a second later, `setPin` set to `false`. That's our blink.

Debug mode also opens port `9230` for attaching the Chrome browser developer tools. The catch is that the source path inside the container is `/usr/src/app/lib`, different from the host path. To set breakpoints, use this path when loading files.

With three instances of the developer tools we can set breakpoints in the front end, the simulated cloud (port `9229`), and the simulated device (port `9230`).

What has changed inside the box?

We have a new directory `iot` with code that runs in the device. Two important files inside `iot/lib`:

* `iot++.json` Describes changes to the baseline IoT device configuration in <Link to="../../apis/#caf_iot">iot.json</Link>.
* `iot_methods.js` Your code.

Section <Link to="#iot-device">IoT Device</Link> covers `iot_methods.js`.

In `lib/*.json` we have added a new <Link to="../../apis/#caf_iot">IoT</Link> plugin. Also, `ca_methods.js` has new methods called by the device, and `hello()` propagates the authentication token to the `Gadget` app.

</DocsSection>

<DocsSection id="raspberry-pi">

## Add a Raspberry Pi

#### Requirements

Raspberry Pi 3/4 with a modern (2020 or later) Raspberry Pi OS.

Install in the RPi both *Docker* and the *Caf.js* management daemon, as described in <Link to="../../apis/#caf_rpi">here</Link>.

For this discussion we assume *Caf.js Cloud* hosting. It is also possible to integrate an RPi with a local deployment by using the laptop external IP address, and not the local loop address. See <Link to="#tools">Tools</Link> for details.

#### IoT Device App

Deploy the previous `myapp` in the Cloud. See <Link to="#cafjs-cloud"> Caf.js Cloud</Link>.

When the name of the device is, for example, `antonio-device1`, both the `Gadget` and `myapp` instance names should be `device1`.

After that, the experience should be similar to the simulated case. But instead of printing log messages, the GPIO pin in the RPi should turn on and off, blinking a light, or making a sound, based on what is connected to the GPIO pins.


</DocsSection>

<DocsSection id="three-way-isomorphic">

## Three-way Isomorphic

We discussed the benefits of a three-way isomorphic framework <Link to="/permanent#three-way">here</Link>.


#### Requirements

We tested this app with a [Puck.js](https://www.puck-js.com/), a programmable Bluetooth beacon. This beacon is very easy to program using JavaScript, and we can add GATT services and advertisements with a few lines of code. See [HelloPuck](https://github.com/cafjs/caf_hellopuckjs.git) for details.

If you do not have a `Puck.js`, you should be able to easily adapt this example to other Bluetooth devices. Configure GATT services and characteristics in `lib/ca++.json`. Change payload types in `iot/lib/iot_methods.js`.

The Web Bluetooth API is supported by the *Chrome* browser in both Android and desktop platforms. *Firefox* or *Safari* will not work. For *Apple iOS* we have sucessfully run simple examples with the [WebBLE](https://apps.apple.com/us/app/webble/id1193531073) browser, but some code changes are needed. [Bluefy](https://apps.apple.com/us/app/bluefy-web-ble-browser/id1492822055) is another *Apple iOS* browser option.

#### Bluetooth App

Let's build a three-way isomorphic Bluetooth app with *Caf.js*.

```shell
cd playground; rm -fr app;  cafjs generate myapp iotbrowser ./app
```

and then install, build, and run.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

With *Chrome*, login and create an instance of `myapp` with publisher `root`, app name `myapp`, and instance name `puck1`.

Switch the `Browser Daemon` option to `on`. It will create a tab with a new hostname `http://root-myapp.localhost:3003/`. Chrome allows subdomains for `localhost`, and port `3003` provides direct access to `myapp`. The Web Bluetooth API requires `https` or `localhost`. It is also blocked inside a cross-origin iframe. By spawning the iframe into its own page, with a new hostname, we avoid these limitations.

Click `Find`, then `Click to Pair`, select the compatible device, and then confirm. After that, blink the `Puck.js` light, or click the physical `Puck.js` button to start receiving notification from the beacon. Sharing a URL allows someone remote to interact with the beacon, see <Link to="/permanent">Permanent Presence</Link>.

The simulated device runs inside the iframe `index-iot.html`, with the same origin as the top context. Using the *Chrome* developer tools we can debug device code by targeting this iframe.

What about isomorphic?

We can deploy this app unchanged on a Raspberry Pi, see the previous <Link to="#raspberry-pi">section</Link>. Keep the `Browser Daemon` option to `off`. The user interface simplifies, with fewer clicks, but the overall functionality is similar.

Note that you should use a different instance name, matching the Raspberry Pi name, for example, `rpi1` instead of `puck1`. Never reuse an instance name for both browser and RPi.

And this application also executes device code in the Cloud, introspecting device methods in the <Link to="../../apis/#caf_iot">IoT plugin</Link>.

Some important code changes:

* Modify the build system in `bin/build.sh` to `browserify` device code.
* Introduce `iot/lib/main-shim.js` as the new entry point for the device in the browser.
* Spawn a page that executes device code in an iframe (`public/js/components/Finder.js`).
* Add a <Link to="../../apis/#caf_iot_gatt">Bluetooth plugin</Link> in `iot/lib/iot++.json`.
* Add a React app for remote interaction in `public/user`.

</DocsSection>

</DocsArticle>


<DocsArticle id="concepts">

# Concepts

<DocsSection id="components">

## Components

In *Caf.js* we build **everything** with hierarchies of components.

Our component model was inpired by the [SmartFrog Framework](https://en.wikipedia.org/wiki/SmartFrog) and the [Erlang/OTP](https://erlang.org) libraries.

Unless you are writing plugins, or reusing the component framework for something else, it is unlikely that you will write components from scratch. But if you are curious, you can see how <Link to="../../apis/#caf_components">here</Link>.

This section is all about using existing ones.

#### Asynchronous Creation

A component is created with an **asynchronous factory method**. During component construction we can, for example, look up properties in *Redis*, and never block the main loop. With factory methods we can swap implementations without modifying the code.

Even though component construction is asynchronous, *Caf.js* builds a hierarchy of components with a **deterministic order**. A parent component is only inserted in its parent context **after** its children are created in **left to right** order. When the hierarchy is destroyed, the order is reversed. The topmost component is special, it is always there.

Dependencies between components are respected by controlling creation order.

#### Supervision Trees

A parent component periodically checks the health of its children. If one is missing, or in a failed state, it takes one of these three recovery actions:

* Shutdown remaining children in reverse order, and then restart them all.
* Restart only the missing child.
* Ignore the failure.

What if the component keeps failing? Its parent component eventually fails, and the fault bubbles up. If it reaches the top component, the process exits, and *Kubernetes* restarts the container somewhere else.

No more zombie containers due to **shallow** health checking!

#### How to Navigate the Hierarchy?

Every component has a reference, `this.$`, to a context shared with its siblings. Components register with a name, which is unique in that context. For example, if component `foo` is created before sibling component `bar`, `bar` can access `foo` with `this.$.foo`

What about components that are not siblings? Every context has a reference `_` to the topmost component that is allowed to see. Children of this component can be accessed with `this.$._.$`. For example, the logger component is the first child of the topmost component, visible to others as `this.$._.$.log`.

Application code is not allowed to navigate the internal hierarchy. Instead, security proxies to internal components populate `this.$`, and you never use `_`. For example, `this.$.log` is a reference to the logger security proxy, that internally finds the real logger component in `$._.$.log`.

*Caf.js* internals are written in a functional style, hiding these private references in closures.

#### Describing Hierarchies with JSON

```json
{
    "name" : "top",
    "module" : "caf_components#supervisor",
    "description" : "Supervisor for this app.",
    "env": {
        "logLevel": "process.env.LOG_LEVEL||DEBUG",
        "somethingElse": "process.env.SOMETHING_ELSE||{\"goo\":2}",
        "maxRetries" : "process.env.MAX_RETRIES||10",
        "retryDelay" : "process.env.RETRY_DELAY||1000"
    },
    "components": [
        {
            "name" : "log",
            "module": "caf_components#plug_log",
            "description": "Logger service",
            "env" : {
                "logLevel" : "$._.env.logLevel"
            }
        },
        {
            "name" : "foo",
            "module": "./myApp",
            "description": "My app component",
            "env" : {
                "somethingElse" : "$._.env.somethingElse",
                "message" : "Hello"
            }
        }
    ]
}
```

The JSON file above, `components.json`,  describes a parent component `top` with two children components `log` and `foo`. Since `foo` is created after sibling `log`, it can safely find the logger with `this.$.log`.

The attribute `module` identifies the factory method that instantiates the component. For example, for `caf_components#supervisor` the factory method will be found with `module.require("caf_components").supervisor`.

The attribute `env` specifies initialization properties for the component. Three examples of property value types:

* `Hello`: a JSON serialized type. If JSON parsing fails, we assume it was a string that was not quoted.
* `process.env.LOG_LEVEL||DEBUG`: a system environment property. If `LOG_LEVEL` is not set, we use `DEBUG` as default. Resolved values are always JSON serialized types.
* `$._.env.logLevel`: a reference to the topmost `env`. In this case it resolves to `process.env.LOG_LEVEL||DEBUG`.

To create an instance of the hierarchy, *Caf.js*  merges the instantiation properties with the topmost `env`. And this happens before resolving any other properties.

Combined with linking, we can configure internal components without knowing the internal structure of the description.

#### Patching JSON Descriptions

In most cases we do not create descriptions from scratch. We use a base description as a template, and change a few attributes, or add/delete some components.

To change `components.json` create a new description called `components++.json` that will be merged with `components.json`.

For example, to modify the `message` property

```json {7}
{
    "name" : "top",
    "components": [
        {
            "name": "foo",
            "env": {
                "message": "Goodbye"
            }
        }
    ]
}
```

or set `module` to `null` to delete the `foo` component

```json {6}
{
    "name" : "top",
    "components": [
        {
            "name": "foo",
            "module": null
        }
    ]
}
```

or to insert a new component `bar` before `foo`

```json {4-6}
{
    "name" : "top",
    "components": [
        {
            "name": "log"
        },
        {
            "name" : "bar",
            "module": "./myApp",
            "description": "My other app component",
            "env" : {
                "somethingElse" : "$._.env.somethingElse",
                "message" : "Whatever"
            }
        }
    ]
}
```

Note the "touch" operation to indicate the insertion position in the array. Insertion of a component with a new key is right after the last array operation.

</DocsSection>


<DocsSection id="cloud-assistant">

## Cloud Assistant

The Cloud Assistant (CA) is the main abstraction provided by the *Caf.js* framework. The foundation of a CA is the Actor Model. *Caf.js* makes actors transactional, and mediates access to the external world with transactional plugins.

The internal state of a CA is **always** consistent with its external commitments, even after server failures.

The  <Link to="/orchestration#transactional-actors">Reliable Service Orchestration</Link> section described the Actor Model, our transactional plugins, the CA checkpointing implementation with *Redis*, and the recovery strategies after a failure.

In this section we focus on what all this means for your code.


#### Hello World
```js
const caf = require('caf_core');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async getCounter() {
        this.$.log && this.$.log.debug('getCounter()')
        return [null, this.state.counter];
    }
};
caf.init(module);
```

The file `ca_methods.js` is the entry point for your application. You can change the name of this file by changing configuration properties, but it can be confusing for others reading your code if you do so.


This file exports a mixin of methods for your CA using the property `methods`.
There are two types of methods:

* **Internal methods** called by the framework. They always have a prefix name `__ca_`. For example, `__ca_init__()` will be called by *Caf.js* the first time the CA is initialized.
* **External methods** called by remote clients. They are all the others. For example, `getCounter()` can be invoked by an authorized client to know the current counter value.

Methods are `async` methods, and always return an array. This array represents a tuple error-value, where an optional application-level error is the first element of the array, and an optional second element is the value returned to the client when there are no errors.

A *Caf.js* application loads with `caf.init()`. We pass as an argument the current `module` object,  to facilitate finding descriptions and plugins that share directory with the file `ca_methods.js`. The *Caf.js* loader maintains a list of `module` objects, and tries them in sequence until it finds the resource.

A CA keeps internal state in two properties:

* `this.state`: Checkpointed state, needs to be JSON-serializable, and always modified within a transaction.
* `this.scratch`: Non-transactional state, not checkpointed, but can be anything. Typically used for caching data, or debugging.

Think of a CA as a sealed object.  Never add state outside these two properties.

Access plugins with `this.$`. For example, `this.$.log` returns a proxy to the logger service, and `this.$.log.debug()` adds a debug message to the log.
 To configure plugins *Caf.js* uses JSON descriptions, as we discussed in the <Link to="#headless-example">Introduction</Link>.

#### Request Serialization

```js {11}
const caf = require('caf_core');
const util = require('util');
const setTimeoutPromise = util.promisify(setTimeout);
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        await setTimeoutPromise(1000);
        return this.getCounter();
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

A CA serializes requests with a queue. Before processing the next request in the queue, it ensures that the current one has finished, even if that requires waiting for the completion of several asynchronous steps.

Serialization does not reduce performance. There could be thousands of CAs in a single process, and blocking one of them does not affect the others, since each CA has its own queue, and its state is private.

And serialization in *Caf.js* is a cluster-wide property. Servers can fail, with hundreds of processes spread across many servers running your app, but CA requests will always be processed one after another.

What is the Big Deal?

Serialization enables a **much simpler** programming abstraction.

Let's assume that `increment()` is expected to return a unique value each time is called.

The innocent looking `increment()` method would have a subtle bug if it were implemented in the same way with existing web application frameworks, such as `Express`.

If one request is waiting for the timeout, and another one starts executing, the second one will also update `this.state.counter`. When the first one ends the timeout, it will return the current value of `this.state.counter`, which was updated by the second request. Now both return the same value.

And races tend to break things when the system is under heavy load, in production, not when doing simple testing. With the convenience of `async/await` primitives in modern *JavaScript*, introducing races is so much easier...

#### Error Handling
```js  {10,13}
const caf = require('caf_core');
const assert = require('assert');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment(n) {
        if (n < 0) {
            return [new Error('Only increment!')];
        } else {
            this.state.counter = this.state.counter + n;
            assert(!isNaN(this.state.counter));
            return this.getCounter();
        }
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

There are two kinds of errors:

* **Application-level** errors that your code knows best how to handle. These are errors returned in the first element of the array.
* **Unrecoverable** errors, mostly bugs, which *Caf.js* does not expect your code to handle gracefully. These are uncaught exceptions thrown by your code.

The client library handles these two types of errors very differently, as we will see <Link to="#client">soon</Link>.

But a CA always aborts the transaction associated with the request. This means that any changes to `this.state` are reversed, and all the transactional plugins will also abort, avoiding any external side-effects.

Again, this enables a **much simpler** programming abstraction.

In the example above, a negative increment is handled as an application-level error, because we assume the client code could do something about it, like suggesting a different service that can decrement.

What happens if the input `n` is the string `oops`? The comparison with `0` is `false`, and we get a `NaN` after the addition. The assertion throws, creating an unrecoverable error.

In this case a traditional web application framework would have corrupted the state of this CA forever. With millions of cheap CAs, expected to run for years with minimal supervision, manual recovery is not in the menu. This is a disaster.

Note that we are **not** encouraging to delay input validation, or promote other bad programming habits, but mistakes happen, and it is a good idea to have a safety net.

#### External Consistency
```js {10}
const caf = require('caf_core');
const assert = require('assert');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        this.$.session.notify([this.state.counter]);
        if (this.state.counter <= 100) {
            return this.getCounter();
        } else {
            return [new Error('Limit exceeded')];
        }
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

The internal state of a CA is always consistent with its external commitments.

This sounds a bit abstract, let's give an example to clarify what we mean.

*Caf.js* uses a transactional plugin, `session`, to send events to clients. We will talk about sessions in the <Link to="#autonomous">next</Link> section but, for this discussion, it is just a plugin with external side-effects.

Calling `increment()` adds one to `this.state.counter`, and sends a new event with the new counter.

What happens when the counter exceeds `100`? It returns an error, aborting the transaction, and `this.state.counter` rolls back to `100`.

But what about the event? The external world saw that the internal state is `101`, but that is inconsistent with the current value of `100`.

And this is also a problem for smaller values. If we send the event, and then the server crashes **before** checkpointing, the state update is lost forever. And the world saw the new value.

In most frameworks the missile has already launched, and there is not much we can do about it.

But in *Caf.js* we use transactional plugins to externalize state changes. For example, when we call `this.$.session.notify()`, the plugin just appends to a log our intent to send the event, but it does **not** sent it. Only when the request commits, and the log of actions and the state changes have been checkpointed, the event is sent.

Transactional plugins **compose** using a two-phase commit protocol. We can mix plugins from different providers, and commit them atomically, or abort all of them if one cannot commit. But this happens behind the scenes, application code does not see this complexity.

And yet again, this enables a **much simpler** programming abstraction.


#### Learn More

A CA can do much more. Update the schema of its internal state safely. Read application properties from the environment. Customize actions after hibernation.

See the jsdoc documentation <Link to="../../apis/#caf_ca">here</Link>.

</DocsSection>


<DocsSection id="autonomous">

## Autonomous Computation

In the introduction to <Link to="../../autonomous">Autonomous Computation</Link> we described a few use cases, and gave an overview of notifications in *Caf.js*.

This section is all about implementing these ideas in your applications.

#### Sessions

When spawning a long term activity in the Cloud, it is crucial to manage notifications for offline clients. This means queueing them in the Cloud until clients are ready to read them. But it also means ensuring that *Caf.js* does not run out of memory with a leaky queue. And when the client is back online, low latency interaction is a must.

What is the best strategy to manage notification queues?

It depends. Limiting queue size is a given, but deciding what to evict is not. Shall we stop queueing new notifications, or remove the old ones, or just keep the last one, or delete redundant ones, or ...

*Caf.js* sets some sensible limits, but it also makes the notification queues visible to application code. Your autonomous code can supervise the queues.

And a notification queue has a name. A simple name that matches the session name chosen by the client. Swap client devices, type this name, and your notifications will follow you. Or use a different name per device to keep them separately.

Let's show an example

```js {6,9-15}
const caf = require('caf_core');
const SESSION = 'admin';
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        this.$.session.limitQueue(1, SESSION);
        return [];
    },
    async __ca_pulse__() {
        this.state.counter = this.state.counter + 1;
        if (this.state.counter % this.$.props.divisor === 0) {
            this.$.session.notify([this.state.counter], SESSION);
        }
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        return this.getCounter();
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

To make your CA autonomous, implement the `__ca_pulse__()` method, and the runtime will call it periodically.

How often? The default is every 2 seconds, but you can change that in `framework++.json`. Just modify the `interval` property of the `cron_pulser` component.

In this case `__ca_pulse__()` increments a counter, and whenever the counter is a multiple of `divisor`, it sends a notification to a queue named `admin`. Note that `this.$.props.divisor` is a property configured in `ca++.json`.

Calling `limitQueue()` overrides the default configuration, and the queue just keeps the last notification.

When a client connects with a session named `admin`, it first receives this last notification. And then, it keeps receiving new notifications in real-time until it disconnects.

##### Notification Groups

Delivering a notification removes it from the queue. When several clients need to see the same notification, use multiple queues and duplicate notifications.

What if the number of clients is not known a priori? Queues are created on-demand, and we address them with regular expressions.

Let's see an example.


```js {2,11}
const caf = require('caf_core');
const SESSION = /^admin/;
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async __ca_pulse__() {
        this.state.counter = this.state.counter + 1;
        if (this.state.counter % this.$.props.divisor === 0) {
            this.$.session.notify([this.state.counter], SESSION);
        }
        return [];
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

When a client calls `getCounter()`, its session name will be added to the notification group, if it starts with `admin`. A name suffix could be random, or based on the username, or chosen by the user. The goal is to avoid name collisions with other clients. After being offline, the client could reuse the session name to receive the pending notifications.

*Caf.js* could run out of memory if it cannot control the number of sessions in the notification group. There is a system-wide property to do that, `maxSessions`, that can be changed in `ca++.json`, or through environment properties. Similarly, `maxMessages` will limit the maximum number of messages in any queue.

When the `maxSessions` limit has been reached, any session that is offline, and has not set a custom limit of messages, can be garbage collected. This means that your pending notifications may not be there when you reconnect.


#### Learn More

A persistent session can guarantee that an stateless client recovers gracefully after a crash, avoiding duplicated requests. See <Link to="../../apis/#caf_session">Persistent Session</Link> for details, and the app [HelloFail](https://github.com/cafjs/caf_hellofail.git) for an example.

</DocsSection>

<DocsSection id="client">

## Client Library

The *Caf.js*  <Link to="../../apis/#caf_cli">Client Library</Link> is a tiny library that just needs web socket support. It works in the browser, in the Cloud, with your scripts, and with embedded devices. Currently JavaScript-only, but more languages will be added soon.

The goal of this library is to create an authenticated session with a CA, and then provide a request-response model, and a notification model, using a common abstraction.

#### Authentication

JSON Web Tokens (JWTs) embedded in URLs is the main mechanism for client authentication. Tokens are self-describing, typically short-lived, and signed with the private key of the [Accounts](https://github.com/cafjs/caf_accounts.git) service. Its corresponding public key is always available, and apps validate tokens locally.

Tokens form a semi-lattice, making it easier to weaken them on-demand. By scoping a token to a particular app, owner, or CA name, we eliminate man-in-the-middle attacks, and reduce the damage of a compromised token.

The [Launcher](https://github.com/cafjs/caf_launcher.git) app manages your tokens in the background, renewing and weakening them as needed. It provides Single Sign-On (SSO) for all your CAs. Before redirecting to another app, it just adds the correct token to the URL.

This means that the client library has very little work to do. In most cases, it just extracts the token from a fragment in the URL, and sends it to the CA for validation using TLS.

What happens if there is no valid token in the URL?

The client library calls a `TokenFactory` hook method that will create the token based on other credentials, for example, your username and password for the `Accounts` service.

The client script in our <Link to="#headless-example">first app</Link> shows how to use the SRP `TokenFactory`.

In the following examples the security plugin has been disabled.

#### Request-Response

```js {2,6}
const caf_cli = require('caf_core').caf_cli;
const URL = 'http://root-hello.vcap.me:3000/#from=foo-ca1&ca=foo-ca1';
const s = new caf_cli.Session(URL);
s.onopen = async function() {
    try {
        let counter = await s.increment(7).getPromise();
        console.log(counter);
        counter = await s.getCounter().getPromise();
        console.log(counter);
        s.close();
    } catch (err) {
        // Application-level error
        s.close(err);
    }
};
s.onclose = function(err) {
    if (err) {
        console.log(`Got exception ${err}`);
        process.exit(1);
    }
    console.log('Done OK');
    process.exit(0);
};
```
The script above first creates a session with CA `foo-ca1`. There are two fields in the URL fragment, `from` and `ca`, and they are the same. This means that the client is acting as the **owner** of this CA, and the CA will be created if needed. Most clients act as owners, and they always have full access. However, in order to claim a `from` origin, a matching authentication token (not shown) needs to be part of the URL.

After creating the session the `onopen` handler gets called, and we can invoke remote methods on this CA. But there is some magic behind the scenes.

CA methods `increment()` and `getCounter()` become methods of session `s`. The client library has downloaded some metadata from the server, and it has created local methods matching the CA remote methods. These local methods will do sanity checks on the arguments before forwarding requests.

What about error handling?

As we discussed in the <Link to="#cloud-assistant">Cloud Assistant</Link> section, there are two types of errors:

* An **Application-level** error, i.e., the first element of the returned array, is used by the client library to reject the returned *Promise*. Therefore, `await` will throw, and the error can be managed inline.
* An **Unrecoverable** error, i.e., exceptions thrown by your CA code, will instead close the session, returning the error in the `onclose` handler.

Just to confuse you, this example handles an application-level error by closing the session with it, a common pattern of simple scripts. But there is no need of closing the session, we could just continue.

What happens if we call multiple methods on the session without `await`? The session has a local queue, and serializes requests. Some recoverable errors are also handled transparently by retrying the last request. If you want multiple concurrent requests, create multiple sessions. But remember that the CA will serialize them anyway...

#### Notifications

```js {4,17-20}
const caf_cli = require('caf_core').caf_cli;
const util = require('util');
const setTimeoutPromise = util.promisify(setTimeout);
const URL = 'http://root-hello.vcap.me:3000/#session=admin&from=foo-ca1&ca=foo-ca1';
const s = new caf_cli.Session(URL);
s.onopen = async function() {
    try {
        let counter = await s.increment(7).getPromise();
        console.log(counter);
        await setTimeoutPromise(10000)
        s.close();
    } catch (err) {
        // Application-level error
        s.close(err);
    }
};
s.onmessage = function(msg) {
    const counter = caf_cli.getMethodArgs(msg)[0];
    console.log(`Got notification ${counter}`);
};
s.onclose = function(err) {
    if (err) {
        console.log(`Got exception ${err}`);
        process.exit(1);
    }
    console.log('Done OK');
    process.exit(0);
};
```

Let's add notifications to our previous example. A couple of changes:

* Provide a session name in the URL. We use the name `admin` to match the queue name in the previous CA example.
* Create an `onmessage` handler that will receive each notification.

Using `getMethodArgs()` we can extract the counter value from the notification.


#### Learn More

Why do we need `getPromise()`? Multi-method requests, that extend the scope of a transaction to a sequence of CA methods.

And more... Encrypt messages end-to-end with Diffie-Hellman keys. Synchronize local time with the Cloud.

See the <Link to="../../apis/#caf_cli">jsdoc</Link> for details.


</DocsSection>

<DocsSection id="trusted-bus">

## Trusted Bus

In the <Link to="../../collaborative">Collaborative Multi-tenancy</Link> overview, we talked about the importance of bootstrapping trust between users of one app, and how a *Trusted Bus* abstraction helped with that goal.

A *Trusted Bus* mediates **internal** interactions between users, authenticating requests, and enforcing access control policy at the target endpoints.

The emphasis is on **internal**. Within **one** app.

The client library is not designed for internal interactions between untrusted peers. Authentication tokens will be compromised. This could be fixed with public-key cryptography, but the performance hit, and key management complexity, makes it impractical.

Can we authenticate requests without tokens, or other crypto?

Sure, if every possible request source is trusted, and requests in transit cannot be modified.

The *Caf.js Cloud* configures Kubernetes network policy to do just that. The *Node.js* processes of your application live in their own network bubble, isolated from other apps.

And application code does not directly access the network. Instead, it uses plugins that have been wrapped by security proxies. These proxies do not trust the application code, adding to each request the name of the CA that sends it.

This makes it less likely that a bug in your application will compromise authentication. After all, your code does not do anything, and authentication is transparently handled by proxies.

What about authorization?

*Caf.js* always performs an access control check at the destination, before calling  a CA method. It also makes the caller CA name visible, while the method executes, with `this.$.security.getCallerFrom()`.

But your code configures policy. And the rest of this section explains how.

#### Defaults

The default policy is **trust no one**. The owner is the only one that can invoke methods on a CA.

And allowed interactions are external-only, using the client library, with owner requests where the `from` and `ca` properties match, as described in the <Link to="#client">Client Library</Link> section.

No *Trusted Bus* interaction.

If nothing works, **check the security policy** first...

#### Simple Rules

Naming conventions simplify policy.

In *Caf.js* naming is based on local namespaces.The name of a CA is always relative to its owner, for example, `foo-ca1` means the user `foo` owns a CA named `ca1`. The name of a `SharedMap` is always relative to the CA that owns it, for example, `foo-ca1-friends`. And so on...

It is easy to enforce and describe policies based on ownership.

For example, to enable CAs with the same owner, using the *Trusted Bus*, to call the method `getCounter()` on each other.

```js {5-8}
const caf = require('caf_core');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        const rule = this.$.security.newSimpleRule(
            'getCounter', this.$.security.SELF
        );
        this.$.security.addRule(rule);
        return [];
    },
    async getCounter() {
        this.$.log && this.$.log.debug('getCounter()')
        return [null, this.state.counter];
    }
};
caf.init(module);
```

More examples.

To open all the CA methods

```js
const rule = this.$.security.newSimpleRule(null, this.$.security.SELF);
```

or to enable CA with local name `ca3` of my friend `joe`, i.e., `joe-ca3`.

```js
const rule = this.$.security.newSimpleRule(null, 'joe', 'ca3');
```

Note that to allow external interactions with the client library there is a "secret" method that also needs to be enabled, `__external_ca_touch__`.

Prefer the *Trusted Bus* over external interaction. It is no longer your code making requests. There are dragons out there...

#### Aggregate Rules

To describe a dynamic policy, potentially shared by many CAs, *Caf.js* uses a *SharedMap*.

A *SharedMap*  is a replicated Distributed Data Structure (DDS) that can only be written by its owner. We describe *SharedMap* <Link to="#sharedmap">here</Link>.

For example, assuming that each owner has a CA named `admin` that maintains policy for all its CAs:

```js
const caf = require('caf_core');
const ADMIN_CA = 'admin';
const ADMIN_MAP = 'primaryACL';
const isAdmin = function(self) {
    const name = self.__ca_getName__();
    return (caf.splitName(name)[1] === ADMIN_CA);
};
const primaryMap = function(self) {
    const name = self.__ca_getName__();
    return caf.joinName(caf.splitName(name)[0], ADMIN_CA, ADMIN_MAP);
};
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        isAdmin(this) && this.$.sharing.addWritableMap('acl', ADMIN_MAP);
        this.$.sharing.addReadOnlyMap(
            'aclAgg', primaryMap(this), {isAggregate: true}
        );
        const rule = this.$.security.newAggregateRule(
            'getCounter', 'aclAgg'
        );
        this.$.security.addRule(rule);
        return [];
    },
    async changePolicy(principal, isAllowed) {
        if (isAdmin(this)) {
            const $$ = this.$.sharing.$;
            if (isAllowed) {
                $$.acl.set(principal, true);
            } else {
                $$.acl.delete(principal);
            }
            return [];
        } else {
            return [new Error('Not an admin')];
        }
    },
    async getCounter() {
        this.$.log && this.$.log.debug('getCounter()')
        return [null, this.state.counter];
    }
};
caf.init(module);
```

Each CA:

* Finds the name of the *SharedMap* managed by the owner's `admin` CA.
* Creates a read-only replica.
* Sets an access control rule based on that replica.

In addition, each `admin` CA:

* Creates a writable *SharedMap* to maintain the set of principals allowed to access the method `getCounter()`.
* Provides a `changePolicy()` method to update this *SharedMap*. Only the owner of the `admin` CA can invoke this method.

Principals can be a CA name, like `foo-ca1`, but also the name of a CA owner, such as `foo`. For the latter case, all the CAs owned by `foo` will be allowed.

##### Delegation

Maintaining the quickly changing membership of a large group is a team effort.

```js
const LINK_KEY = '__link_key__';
exports.methods = {
    \\ after changePolicy()
    async linkNamespace(ns, isAllowed) {
        if (isAdmin(this)) {
            const $$ = this.$.sharing.$;
            const all = new Set($$.acl.get(LINK_KEY) || []);
            isAllowed ? all.add(ns) : all.delete(ns);
            $$.acl.set(LINK_KEY, [...all]);
            return [];
        } else {
            return [new Error('Not an admin')];
        }
    },
    \\ before getCounter()
}
```

#### Learn More


</DocsSection>

<DocsSection id="sharedmap">

## SharedMap

</DocsSection>

<DocsSection id="publish-subscribe">

## Publish-Subscribe

</DocsSection>

<DocsSection id="iot-device">

## IoT Device

</DocsSection>

</DocsArticle>

<DocsArticle id="apis">

# APIs

You can see the jsdoc documentation <Link to="/apis">here</Link>
</DocsArticle>

<DocsArticle id="tools">

# Tools

</DocsArticle>
<DocsArticle id="resources">

# Resources

</DocsArticle>

</DocsContent>
