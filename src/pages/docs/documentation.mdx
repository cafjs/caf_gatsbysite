---
title: Documentation
---

<DocsSidebar/>

<DocsContent>

<DocsArticle id="getting-started">

# Getting Started

<DocsSection id="install">

## Install

#### Software Requirements

`node` >= 12 (LTS only), `yarn` >= 1.20, and `docker` >= 19.

We rely on `yarn` workspaces, and `npm` does not support them yet.

Our development is mostly on Linux. Best platform for running `docker` containers.

#### Download

Clone the main repository

```shell
git clone https://github.com/cafjs/caf.git
```

Update submodules

```shell
cd caf; git submodule update --init
```

Install dependencies

```shell
yarn run installAll
```

Add to your path the `cafjs` tool binary

```shell
export PATH=<your_install_directory>/caf/bin:$PATH
```

Download the latest `docker` images

```shell
cafjs update
```

#### Test

Let's build and run locally a simple app.


```shell
cd apps/caf_helloworld; cafjs build; cafjs run helloworld
```

With `docker ps` you should see seven running containers. They simulate the support services that we run in the Cloud.

The app launcher URL is http://root-launcher.vcap.me (DNS resolves `*.vcap.me` to `127.0.0.1`, the local loop). Using your browser, login with user `foo` and password `bar`. Then, with the top left menu, click the `+` icon to add a `helloworld` app instance.

Fill the form with:

* App publisher: `root` (in local mode apps are always published by `root`)
* App name: `helloworld`
* CA name: anything containing ASCII characters and numbers.

and a `counter` example should appear. Use the `+` again to create other instances, and then switch between them with the top left menu.

To stop it, a single `Control-C` will initiate a gentle container shutdown but, for the impatient, a second `Control-C` will brute force a clean-up. Double tap.

In both cases we should be able to restart without losing the previous state, since the Redis container generates a checkpoint file in the host diretory `/tmp`. Delete this file to start from scratch:

```shell
sudo rm /tmp/redis/appendonly.aof
```

Finally, when containers hang, we can always use the nuclear cleanup option

```shell
cafjs reset
```

</DocsSection>

<DocsSection id="headless-example">

## Your First App

Let's create a simple app with no front end.

*Caf.js* is managed as a monorepo using `yarn` workspaces. Anything under the sub-directory `caf/playground/app` becomes part of the workspace, and we will create the app there.

Using a monorepo has many advantages, but the most important one is that you know what you are getting. When we create a release of *Caf.js* we freeze all our packages, and test them together. Your app will not suffer from semver mistakes due to these packages.

To create the app skeleton we use `cafjs generate`, an application template generator. The default templates are in a Docker image, and it is easy to customize and share your templates by publishing a new image. See  <Link to="#tools">Tools</Link> for details.

```shell
cd playground; rm -fr app;  cafjs generate myapp cloud ./app
```

and then install, build, and run. Install is only needed for the first build, to update dependencies in the monorepo.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

This time we used the flag `-d` to turn on debugging mode. You should see debug logs in the console. It also opens the debug port `9229`, and you can set breakpoints, and inspect variables, with the Chrome browser developer tools (`chrome://inspect`). The *Redis* instance is also accessible in host port `6380`.

There is no front end, and we use a script in the `util` directory to read state, and subscribe to notifications.

```shell
cd util; ./client.js --url http://root-myapp.vcap.me bar foo-ca1
```

What is in the box?

We will use this example to introduce *Caf.js* programming in the <Link to="#concepts">next</Link> section. Let's look at the files in the `lib` directory first:

* `rsa_pub.pem` A dummy public key to validate authentication tokens in a local deployment. When you deploy your app in the *Caf.js Cloud*, we swap this key by the "real" one.
* `framework++.json` Describes changes to the baseline platform configuration in <Link to="../../apis/#caf_platform">framework.json</Link>.
* `ca++.json` Describes changes to the baseline cloud assistant configuration in <Link to="../../apis/#caf_ca">ca.json</Link>.
* `ca_methods.js` Your code.

To understand the json files have a look at our <Link to="#components">component model</Link>. Sections <Link to="#cloud-assistant">Cloud Assistant</Link> and <Link to="#autonomous">Autonomous Computation</Link> cover `ca_methods.js`. The script is explained in the <Link to="#client">Client Library</Link>.

</DocsSection>

<DocsSection id="add-react-frontend">

## Add a React User Interface

Let's add a *React* front end to the previous app.

```shell
cd playground; rm -fr app;  cafjs generate myapp web ./app
```
and again:

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

and now, as we did for testing the <Link to="#install">installation</Link>, login with the browser, and create a few instances with app name `myapp`, and `root` publisher, since we are in local mode.

The app uses <Link to="/autonomous">Proactive Server Side Rendering (PSSR)</Link> for fast app switching. The json files add the required <Link to="../../apis/#caf_react">React plugin</Link>.  In `ca_methods.js` there is also a new method `hello()`, which provides the cache key for rendering, and a few calls to the new plugin. Without PSSR the cloud code would look similar to the previous example.

The code in `public` is mostly a standard `React` app, which uses `redux` to manage state, and `react-bootstrap` components to build the UI.

The only novelty is a session object to connect to a cloud assistant in `AppSession.js`, binding actions to remote methods in `AppActions.js`, and a custom initialization in `app.js`.

These are **not** hard dependencies. This is just an example integrating *Caf.js* with a front end, using libraries that we are familiar with. There are no *Caf.js* dependencies with `react-bootstrap`. Replacing `redux` by another state management solution just needs a simple integration with the client library, similar to `AppActions.js`. For PSSR, replacing `React` by another framework would require a new plugin though.


</DocsSection>

<DocsSection id="cafjs-cloud">

## Caf.js Cloud

If you are self-hosting your apps, skip this section.

The *Caf.js Cloud* is currently in beta, and this section is likely to change.

#### Requirements

Create a *Caf.js Cloud* account [here](https://root-launcher.cafjs.com).

Login and create an instance of the [Turtles](https://github.com/cafjs/caf_turtles.git) deployer (app publisher `root`, app name `turtles`, choose any name for your instance).

To publish a **public** `Docker` image containing your app, you need an account on a public Docker registry. For example, [Docker Hub](https://hub.docker.com),  [GitHub Container Registry](https://docs.github.com/en/packages/guides/about-github-container-registry), and [GitLab Container Registry](https://docs.gitlab.com/ee/user/packages/container_registry/), they all have free plans. We use internally the [Google Container Registry](https://cloud.google.com/container-registry).

If you do not have a registry account, but just want to try `Turtles`, the image for this example is `gcr.io/cafjs-k8/root-webexample`.

#### Deploy

Let's create an image with the previous app. Change the image name prefix to match your registry provider.

```shell
cd playground/app; cafjs mkImage . gcr.io/cafjs-k8/root-webexample
```

Ensure that it runs fine before uploading

```shell
cafjs run --appImage gcr.io/cafjs-k8/root-webexample myapp
```

and then create local instances as before.

Now we are ready to upload the image

```shell
docker push gcr.io/cafjs-k8/root-webexample
```

Login to *Caf.js Cloud* `https://root-launcher.cafjs.com` using a browser.

And then, to go live, you need to do two things:

* Register the app with the top left menu.
* Deploy with `Turtles`.

When you register this app, choose a name, a plan, and the percentage of profit that you want to make. Based on that your app gets a price in subscription-days per unit. A unit is 10 cents plus fees. See section <Link to="../../hosting">Caf.js Cloud</Link> for details.

To deploy with `Turtles` use the previous app and image names. Set `Disable CDN` to `On`, unless you have configured your own CDN in the image. You can also set environment properties for your app. We use properties to configure secrets since images are always public.

Check the status of your app (assuming your username is `antonio`, and the app name is `mycoolapp`)

```shell
curl https://antonio-mycoolapp.cafjs.com/ping
```

and monitor its performance with

```shell
curl https://antonio-mycoolapp.cafjs.com/stats
```

After a few seconds, you, and **every other user**, can create an instance of your app with the top-left menu, using your username `antonio` as publisher, and the previous app name `mycoolapp`.

And when they do, you **keep getting units** for as long as they use your app.

Maintaining a registered app costs one unit per week. Do not forget to **delete** the app with `Turtles`, **and unregister** it with the top left menu, when you are done.

With the `People` app, you can view stats for your registered apps, your active cloud assistants, or the current unit balance. You can also use this app to buy more units, or send/receive units to/from other users. This app is free and always installed.

</DocsSection>

<DocsSection id="add-device">

## Add a Simulated Device

#### Software Requirements

When *Caf.js* simulates a device, it creates images for an ARM processor, and executes ARM binaries. The goal is to be as close as possible to the real thing.

To do that, install in your Linux box the `qemu-user-static` and `binfmt` modules. For example, in Ubuntu:

```shell
sudo apt-get update && sudo apt-get install -y qemu-user-static binfmt-support
```
#### IoT Device App

Let's create an app that provides a <Link to="/permanent">permanent presence</Link> for an IoT device.

```shell
cd playground; rm -fr app;  cafjs generate myapp iot ./app
```
and then install, build, and run.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

The [Gadget](https://github.com/cafjs/caf_gadget.git) app manages IoT devices. Login with the local URL http://root-launcher.vcap.me and create a `Gadget` instance with publisher `root` and app name `gadget`. The instance name should match the name of the device, for example, `device1`.

Create an instance of `myapp` (publisher is always `root` in local deployment), ensure that the instance name matches the device name, i.e., `device1`.

Go back to the `Gadget` instance and set the app name to `root-myapp`. This app does not need privileged mode, but most do, as the pop-up warning explains. You can also set environment properties for the `node.js` process running in the device.

After `Update` you should see `Token=yes` because we created the app after the `Gadget` instance. If that is not the case, just go back to the app, and the token will transparently propagate.

Now we are ready to start the simulated device in another console. Note that the name of the device should be `device1`.

```shell
cafjs device -d foo-device1
```

The first thing the new device does is to download from its `Gadget` instance a Docker image spec for the current app. Building this ARM image takes about a minute in my laptop, but images are cached in the host, and only rebuild when the spec changes. Then, it starts the app in a container.

Since we started the app with `-d` (debug mode), you should see the debug logs in the console. If you go back to the instance of `myapp`, and click `Do it!`, you should see in the log `setPin` set to `true`, and about a second later, `setPin` set to `false`. That's our blink.

Debug mode also opens port `9230` for attaching the Chrome browser developer tools. The catch is that the source path inside the container is `/usr/src/app/lib`, different from the host path. To set breakpoints, use this path when loading files.

With three instances of the developer tools we can set breakpoints in the front end, the simulated cloud (port `9229`), and the simulated device (port `9230`).

What has changed inside the box?

We have a new directory `iot` with code that runs in the device. Two important files inside `iot/lib`:

* `iot++.json` Describes changes to the baseline IoT device configuration in <Link to="../../apis/#caf_iot">iot.json</Link>.
* `iot_methods.js` Your code.

Section <Link to="#iot-device">IoT Device</Link> covers `iot_methods.js`.

In `lib/*.json` we have added a new <Link to="../../apis/#caf_iot">IoT</Link> plugin. Also, `ca_methods.js` has new methods called by the device, and `hello()` propagates the authentication token to the `Gadget` app.

</DocsSection>

<DocsSection id="raspberry-pi">

## Add a Raspberry Pi

#### Requirements

Raspberry Pi 3/4 with a modern (2020 or later) Raspberry Pi OS.

Install in the RPi both *Docker* and the *Caf.js* management daemon, as described in <Link to="../../apis/#caf_rpi">here</Link>.

For this discussion we assume *Caf.js Cloud* hosting. It is also possible to integrate an RPi with a local deployment by using the laptop external IP address, and not the local loop address. See <Link to="#tools">Tools</Link> for details.

#### IoT Device App

Deploy the previous `myapp` in the Cloud. See <Link to="#cafjs-cloud"> Caf.js Cloud</Link>.

When the name of the device is, for example, `antonio-device1`, both the `Gadget` and `myapp` instance names should be `device1`.

After that, the experience should be similar to the simulated case. But instead of printing log messages, the GPIO pin in the RPi should turn on and off, blinking a light, or making a sound, based on what is connected to the GPIO pins.


</DocsSection>

<DocsSection id="three-way-isomorphic">

## Three-way Isomorphic

We discussed the benefits of a three-way isomorphic framework <Link to="/permanent#three-way">here</Link>.


#### Requirements

We tested this app with a [Puck.js](https://www.puck-js.com/), a programmable Bluetooth beacon. This beacon is very easy to program using JavaScript, and we can add GATT services and advertisements with a few lines of code. See [HelloPuck](https://github.com/cafjs/caf_hellopuckjs.git) for details.

If you do not have a `Puck.js`, you should be able to easily adapt this example to other Bluetooth devices. Configure GATT services and characteristics in `lib/ca++.json`. Change payload types in `iot/lib/iot_methods.js`.

The Web Bluetooth API is supported by the *Chrome* browser in both Android and desktop platforms. *Firefox* or *Safari* will not work. For *Apple iOS* we have sucessfully run simple examples with the [WebBLE](https://apps.apple.com/us/app/webble/id1193531073) browser, but some code changes are needed. [Bluefy](https://apps.apple.com/us/app/bluefy-web-ble-browser/id1492822055) is another *Apple iOS* browser option.

#### Bluetooth App

Let's build a three-way isomorphic Bluetooth app with *Caf.js*.

```shell
cd playground; rm -fr app;  cafjs generate myapp iotbrowser ./app
```

and then install, build, and run.

```shell
cd app; cafjs install; cafjs build;  cafjs run -d myapp
```

With *Chrome*, login and create an instance of `myapp` with publisher `root`, app name `myapp`, and instance name `puck1`.

Switch the `Browser Daemon` option to `on`. It will create a tab with a new hostname `http://root-myapp.localhost:3003/`. Chrome allows subdomains for `localhost`, and port `3003` provides direct access to `myapp`. The Web Bluetooth API requires `https` or `localhost`. It is also blocked inside a cross-origin iframe. By spawning the iframe into its own page, with a new hostname, we avoid these limitations.

Click `Find`, then `Click to Pair`, select the compatible device, and then confirm. After that, blink the `Puck.js` light, or click the physical `Puck.js` button to start receiving notification from the beacon. Sharing a URL allows someone remote to interact with the beacon, see <Link to="/permanent">Permanent Presence</Link>.

The simulated device runs inside the iframe `index-iot.html`, with the same origin as the top context. Using the *Chrome* developer tools we can debug device code by targeting this iframe.

What about isomorphic?

We can deploy this app unchanged on a Raspberry Pi, see the previous <Link to="#raspberry-pi">section</Link>. Keep the `Browser Daemon` option to `off`. The user interface simplifies, with fewer clicks, but the overall functionality is similar.

Note that you should use a different instance name, matching the Raspberry Pi name, for example, `rpi1` instead of `puck1`. Never reuse an instance name for both browser and RPi.

And this application also executes device code in the Cloud, introspecting device methods in the <Link to="../../apis/#caf_iot">IoT plugin</Link>.

Some important code changes:

* Modify the build system in `bin/build.sh` to `browserify` device code.
* Introduce `iot/lib/main-shim.js` as the new entry point for the device in the browser.
* Spawn a page that executes device code in an iframe (`public/js/components/Finder.js`).
* Add a <Link to="../../apis/#caf_iot_gatt">Bluetooth plugin</Link> in `iot/lib/iot++.json`.
* Add a React app for remote interaction in `public/user`.

</DocsSection>

</DocsArticle>


<DocsArticle id="concepts">

# Concepts

<DocsSection id="components">

## Components

In *Caf.js* we build **everything** with hierarchies of components.

Our component model was inpired by the [SmartFrog Framework](https://en.wikipedia.org/wiki/SmartFrog) and the [Erlang/OTP](https://erlang.org) libraries.

Unless you are writing plugins, or reusing the component framework for something else, it is unlikely that you will write components from scratch. But if you are curious, you can see how <Link to="../../apis/#caf_components">here</Link>.

This section is all about using existing ones.

#### Asynchronous Creation

A component is created with an **asynchronous** factory method. During component construction we can, for example, look up properties in *Redis*, and never block the main loop. With factory methods we can swap implementations without modifying the code.

Even though component construction is asynchronous, *Caf.js* builds a hierarchy of components with a deterministic order. A parent component is only inserted in its parent context **after** its children are created in **left to right** order. When the hierarchy is destroyed, the order is reversed. The topmost component is special, it is always there.

Dependencies between components are respected by controlling creation order.

#### Supervision Trees

A parent component periodically checks the health of its children. If one is missing, or in a failed state, it takes one of these three recovery actions:

* Shutdown remaining children in reverse order, and then restart them all.
* Restart only the missing child.
* Ignore the failure.

What if the component keeps failing? Its parent component eventually fails, and the fault bubbles up. If it reaches the top component, the process exits, and *Kubernetes* restarts the container somewhere else.

No more zombie containers due to **shallow** health checking!

#### How to Navigate the Hierarchy?

Every component has a reference, `this.$`, to a context shared with its siblings. Components register with a name, which is unique in that context. For example, if component `foo` is created before sibling component `bar`, `bar` can access `foo` with `this.$.foo`

What about components that are not siblings? Every context has a reference `_` to the topmost component that is allowed to see. Children of this component can be accessed with `this.$._.$`. For example, the logger component is the first child of the topmost component, visible to others as `this.$._.$.log`.

Application code is not allowed to navigate the internal hierarchy. Instead, security proxies to internal components populate `this.$`, and you never use `_`. For example, `this.$.log` is a reference to the logger security proxy, that internally finds the real logger component in `$._.$.log`.

*Caf.js* internals are written in a functional style, hiding these private references in closures.

#### Describing Hierarchies with JSON

```json
{
    "name" : "top",
    "module" : "caf_components#supervisor",
    "description" : "Supervisor for this app.",
    "env": {
        "logLevel": "process.env.LOG_LEVEL||DEBUG",
        "somethingElse": "process.env.SOMETHING_ELSE||{\"goo\":2}",
        "maxRetries" : "process.env.MAX_RETRIES||10",
        "retryDelay" : "process.env.RETRY_DELAY||1000"
    },
    "components": [
        {
            "name" : "log",
            "module": "caf_components#plug_log",
            "description": "Logger service",
            "env" : {
                "logLevel" : "$._.env.logLevel"
            }
        },
        {
            "name" : "foo",
            "module": "./myApp",
            "description": "My app component",
            "env" : {
                "somethingElse" : "$._.env.somethingElse",
                "message" : "Hello"
            }
        }
    ]
}
```

The JSON file above, `components.json`,  describes a parent component `top` with two children components `log` and `foo`. Since `foo` is created after sibling `log`, it can safely find the logger with `this.$.log`.

The attribute `module` identifies the factory method that instantiates the component. For example, for `caf_components#supervisor` the factory method will be found with `module.require("caf_components").supervisor`.

The attribute `env` specifies initialization properties for the component. Three examples of property value types:

* `Hello`: a JSON serialized type. If JSON parsing fails, we assume it was a string that was not quoted.
* `process.env.LOG_LEVEL||DEBUG`: a system environment property. If `LOG_LEVEL` is not set, we use `DEBUG` as default. Resolved values are always JSON serialized types.
* `$._.env.logLevel`: a reference to the topmost `env`. In this case it resolves to `process.env.LOG_LEVEL||DEBUG`.

To create an instance of the hierarchy, *Caf.js*  merges the instantiation properties with the topmost `env`. And this happens before resolving any other properties.

Combined with linking, we can configure internal components without knowing the internal structure of the description.

#### Patching JSON Descriptions

In most cases we do not create descriptions from scratch. We use a base description as a template, and change a few attributes, or add/delete some components.

To change `components.json` create a new description called `components++.json` that will be merged with `components.json`.

For example, to modify the `message` property

```json {7}
{
    "name" : "top",
    "components": [
        {
            "name": "foo",
            "env": {
                "message": "Goodbye"
            }
        }
    ]
}
```

or set `module` to `null` to delete the `foo` component

```json {6}
{
    "name" : "top",
    "components": [
        {
            "name": "foo",
            "module": null
        }
    ]
}
```

or to insert a new component `bar` before `foo`

```json {4-6}
{
    "name" : "top",
    "components": [
        {
            "name": "log"
        },
        {
            "name" : "bar",
            "module": "./myApp",
            "description": "My other app component",
            "env" : {
                "somethingElse" : "$._.env.somethingElse",
                "message" : "Whatever"
            }
        }
    ]
}
```

Note the "touch" operation to indicate the insertion position in the array. Insertion of a component with a new key is right after the last array operation.

</DocsSection>


<DocsSection id="cloud-assistant">

## Cloud Assistant

The Cloud Assistant (CA) is the main abstraction provided by the *Caf.js* framework. The foundation of a CA is the Actor Model. *Caf.js* makes actors transactional, and mediates access to the external world with transactional plugins.

The internal state of a CA is **always** consistent with its external commitments, even after server failures.

The  <Link to="/orchestration#transactional-actors">Reliable Service Orchestration</Link> section described the Actor Model, our transactional plugins, the CA checkpointing implementation with *Redis*, and the recovery strategies after a failure.

In this section we focus on what all this means for your code.


#### Hello World
```js
const caf = require('caf_core');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async getCounter() {
        this.$.log && this.$.log.debug('getCounter()')
        return [null, this.state.counter];
    }
};
caf.init(module);
```

The file `ca_methods.js` is the entry point for your application. You can change the name of this file by changing configuration properties, but it can be confusing for others reading your code if you do so.


This file exports a mixin of methods for your CA using the property `methods`.
There are two types of methods:

* **Internal methods** called by the framework. They always have a prefix name `__ca_`. For example, `__ca_init__()` will be called by *Caf.js* the first time the CA is initialized.
* **External methods** called by remote clients. They are all the others. For example, `getCounter()` can be invoked by an authorized client to know the current counter value.

Methods are `async` methods, and always return an array. This array represents a tuple error-value, where an optional application-level error is the first element of the array, and an optional second element is the value returned to the client when there are no errors.

A *Caf.js* application loads with `caf.init()`. We pass as an argument the current `module` object,  to facilitate finding descriptions and plugins that share directory with the file `ca_methods.js`. The *Caf.js* loader maintains a list of `module` objects, and tries them in sequence until it finds the resource.

A CA keeps internal state in two properties:

* `this.state`: Checkpointed state, needs to be JSON-serializable, and always modified within a transaction.
* `this.scratch`: Non-transactional state, not checkpointed, but can be anything. Typically used for caching data, or debugging.

Think of a CA as a sealed object.  Never add state outside these two properties.

Access plugins with `this.$`. For example, `this.$.log` returns a proxy to the logger service, and `this.$.log.debug()` adds a debug message to the log.
 To configure plugins *Caf.js* uses JSON descriptions, as we discussed in the <Link to="#headless-example">Introduction</Link>.

#### Serialization

```js {11}
const caf = require('caf_core');
const util = require('util');
const setTimeoutPromise = util.promisify(setTimeout);
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        await setTimeoutPromise(1000);
        return this.getCounter();
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

A CA serializes requests with a queue. Before processing the next request in the queue, it ensures that the current one has finished, even if that requires waiting for the completion of several asynchronous steps.

Serialization does not reduce performance. There could be thousands of CAs in a single process, and blocking one of them does not affect the others, since each CA has its own queue, and its state is private.

And serialization in *Caf.js* is a cluster-wide property. Servers can fail, with hundreds of processes spread across many servers running your app, but CA requests will always be processed one after another.

What is the Big Deal?

Serialization enables a **much simpler** programming abstraction.

Let's assume that `increment()` is expected to return a unique value each time is called.

The innocent looking `increment()` method would have a subtle bug if it were implemented in the same way with existing web application frameworks, such as `Express`.

If one request is waiting for the timeout, and another one starts executing, the second one will also update `this.state.counter`. When the first one ends the timeout, it will return the current value of `this.state.counter`, which was updated by the second request. Now both return the same value.

And races tend to break things when the system is under heavy load, in production, not when doing simple testing. With the convenience of `async/await` primitives in modern *JavaScript*, introducing races is so much easier...

#### Error Handling
```js  {10,13}
const caf = require('caf_core');
const assert = require('assert');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment(n) {
        if (n < 0) {
            return [new Error('Only increment!')];
        } else {
            this.state.counter = this.state.counter + n;
            assert(!isNaN(this.state.counter));
            return this.getCounter();
        }
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

There are two kinds of errors:

* **Application-level** errors that your code knows best how to handle. These are errors returned in the first element of the array.
* **Unrecoverable** errors, mostly bugs, which *Caf.js* does not expect your code to handle gracefully. These are uncaught exceptions thrown by your code.

The client library handles these two types of errors very differently, as we will see <Link to="#client">soon</Link>.

But a CA always aborts the transaction associated with the request. This means that any changes to `this.state` are reversed, and all the transactional plugins will also abort, avoiding any external side-effects.

Again, this enables a **much simpler** programming abstraction.

In the example above, a negative increment is handled as an application-level error, because we assume the client code could do something about it, like suggesting a different service that can decrement.

What happens if the input `n` is the string `oops`? The comparison with `0` is `false`, and we get a `NaN` after the addition. The assertion throws, creating an unrecoverable error.

In this case a traditional web application framework would have corrupted the state of this CA forever. With millions of cheap CAs, expected to run for years with minimal supervision, manual recovery is not in the menu. This is a disaster.

Note that we are **not** encouraging to delay input validation, or promote other bad programming habits, but mistakes happen, and it is a good idea to have a safety net.

#### External Consistency
```js {10}
const caf = require('caf_core');
const assert = require('assert');
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        this.$.session.notify([this.state.counter]);
        if (this.state.counter <= 100) {
            return this.getCounter();
        } else {
            return [new Error('Limit exceeded')];
        }
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

The internal state of a CA is always consistent with its external commitments.

This sounds a bit abstract, let's give an example to clarify what we mean.

*Caf.js* uses a transactional plugin, `session`, to send events to clients. We will talk about sessions in the <Link to="#autonomous">next</Link> section but, for this discussion, it is just a plugin with external side-effects.

Calling `increment()` adds one to `this.state.counter`, and sends a new event with the new counter.

What happens when the counter exceeds `100`? It returns an error, aborting the transaction, and `this.state.counter` rolls back to `100`.

But what about the event? The external world saw that the internal state is `101`, but that is inconsistent with the current value of `100`.

And this is also a problem for smaller values. If we send the event, and then the server crashes **before** checkpointing, the state update is lost forever. And the world saw the new value.

In other frameworks the missile has already launched, and there is not much we can do about it.

But in *Caf.js* we use transactional plugins to externalize state changes. For example, when we call `this.$.session.notify()`, the plugin just appends to a log our intent to send the event, but it does **not** sent it. Only when the request commits, and the log of actions and the state changes have been checkpointed, the event is sent.

Transactional plugins **compose** using a two-phase commit protocol. We can mix plugins from different providers, and commit them atomically, or abort all of them if one cannot commit. But this happens behind the scenes, application code does not see this complexity.

And yet again, this enables a **much simpler** programming abstraction.


#### Learn More

A CA can do much more. Update the schema of its internal state safely. Read application properties from the environment. Customize actions after hibernation.

See the jsdoc documentation <Link to="../../apis/#caf_ca">here</Link>.

</DocsSection>


<DocsSection id="autonomous">

## Autonomous Computation


`__ca_pulse__()`

how often, change the `interval` property of the `cron_pulser` component in `framework++.json`. The default is every 2 seconds.
#### Sessions



Default limits

```js {6,9-15}
const caf = require('caf_core');
const SESSION = 'admin';
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        this.$.session.limitQueue(1, SESSION);
        return [];
    },
    async __ca_pulse__() {
        this.state.counter = this.state.counter + 1;
        if (this.state.counter % this.$.props.divisor === 0) {
            this.$.session.notify([this.state.counter], SESSION);
        }
        return [];
    },
    async increment() {
        this.state.counter = this.state.counter + 1;
        return this.getCounter();
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```


##### Dynamic Notification Groups

What if the number of clients listening to CA events is not known a priori?

We can use regular expressions to notify multiple clients. Clients can choose a unique session name matching that regular expression.

Let's show an example:

```js {2,11}
const caf = require('caf_core');
const SESSION = /^admin/;
exports.methods = {
    async __ca_init__() {
        this.state.counter = 0;
        return [];
    },
    async __ca_pulse__() {
        this.state.counter = this.state.counter + 1;
        if (this.state.counter % this.$.props.divisor === 0) {
            this.$.session.notify([this.state.counter], SESSION);
        }
        return [];
    },
    async getCounter() {
        return [null, this.state.counter];
    }
};
caf.init(module);
```

When a client calls `getCounter()`, its session name will be added to the notification set, if it starts with `admin`. A name suffix could be random, or based on the username, or chosen by the user. The goal is to avoid name collisions with other clients. After being offline, the client could reuse the session name to receive the pending notifications.

*Caf.js* could run out of memory, or waste network bandwidth, if it cannot control the number of sessions in the notification set. There is a system-wide property to do that, `maxSessions`, that can be changed in `ca++.json`, or through environment properties. Similarly, `maxMessages` will limit the maximum number of messages in any queue.

When the `maxSessions` limit has been reached, any session that is offline, and has not set a custom limit of messages, can be garbage collected. This means that your pending notifications may not be there when you reconnect.


#### Learn More
  Persistent session

</DocsSection>

<DocsSection id="client">

## Client Library

script, browser, cloud and device
#### Request-Response

Serialization, error handling

#### Notifications

#### Learn More

Multi-methods, end-to-end encryption and time synchronization

</DocsSection>

<DocsSection id="trusted-bus">

## Trusted Bus

</DocsSection>

<DocsSection id="sharing-actors">

## Sharing Actors

</DocsSection>

<DocsSection id="publish-subscribe">

## Publish-Subscribe

</DocsSection>

<DocsSection id="iot-device">

## IoT Device

</DocsSection>

</DocsArticle>

<DocsArticle id="apis">

# APIs

You can see the jsdoc documentation <Link to="/apis">here</Link>
</DocsArticle>

<DocsArticle id="tools">

# Tools

</DocsArticle>
<DocsArticle id="resources">

# Resources

</DocsArticle>

</DocsContent>
