---
title: Permanent Presence
---
## Permanent Presence

Modern browsers enable offline experiences for Progressive Web Apps (PWAs) with service workers.

But what about the rest of the world? Services, clients, or devices that need interaction? They all have to wait.

And connectivity is not always symmetric. Most IoT devices are not directly exposed to the Internet, otherwise they would be hacked in an hour.
This makes remote interaction with devices even more difficult.

**Caf.js** makes devices and web app instances always accessible from anywhere at any time. An abstraction that we call **Reverse Service Worker (RSW)** keeps them safe. A **three-way isomorphic** framework enables quick prototyping of new sharing experiences.

Let's look at a few use cases first, and describe the technology after that.

<hr/>

#### Safe sharing of Bluetooth devices

So many Bluetooth devices around us. An indoor exercise bike, a heart rate/ECG monitor, a connected toy, an smart light bulb, a speaker, a temperature sensor, a thermostat, a drone, a fridge, a watch, a battery, a car diagnostics tool...

What if you could instantly share them across the Internet? With your doctor, your fitness instructor, your friend in a Zoom session, your colleagues working from home, a remote expert...

And do that safely, with no setup, with just a browser. E-mail or text a URL to your peer, and when they click on the link they control the device. But only until you revoke access, or the embedded token expires.

With **Caf.js** you can do that with a few hundred lines of JavaScript. There are some examples in GitHub already. [HealthyPi](https://github.com/cafjs/caf_healthypi.git), a cheap ECG/Body temperature/SPO2 monitor.  [Puck.js](https://github.com/cafjs/caf_hellopuckjs.git), a programmable beacon with many sensors. And it is easy to build your own with our app template generator tool, i.e., `cafjs generate yourapp iotbrowser`.

#### Integration of real devices in VR/AR

When your real home is part of a virtual world, and action in VR could switch off the lights of your real home, thousands of miles away.

You could implement this today, by creating an avatar of the lamp, which forwards actions to the physical lamp across the Internet.

But this is hard to get right. Any delays or connectivity issues will ruin the virtual experience. And directly exposing your lamp to the Internet is risky.

Instead, **Caf.js** can take care of the backend for your lamp avatar, ensuring safety and predictable latency. And then you can focus on making the avatar more realistic.

What about AR? You are likely to share the room with the physical lamp. And when you look fixedly at it, a user interface will pop up allowing, for example, a change in the color hue.

The connectivity challenges with AR are not any easier. What if the lamp is in a vacation rental, or in a shop, or at the office? It would be much easier if the AR client device just needed Internet connectivity, and the access policy was centrally managed for all the shared devices, as we do in **Caf.js**.

But the real fun starts with some remote team members in VR, and others local in AR. And they all collaborate in real-time by interacting with shared physical devices. With **Caf.js** all these user interfaces, and the state of the connected physical devices, are always in sync.

For example, an interior designer can configure the lights at your home remotely using VR, and as you see the changes in the real world, you can also suggest modifications in real-time with your AR interface.

A bare bones example to do just that is in GitHub. [Hue](https://github.com/cafjs/caf_hellohue.git) controls a color smart bulb using three interfaces VR, AR, and html, keeping all of them in sync, and in sync with reality.

<hr/>

How are these experiences implemented with **Caf.js**? Let's start with a few new concepts.

#### Reverse Service Workers (RSW)

Service workers enable offline experiences for Progressive Web Apps (PWAs). A service worker runs a custom script, in a separate context from the web page, to mediate network access and cache data. When connectivity is poor, it can pretend that the network is still working by fetching from a local cache or delaying sends.

An RSW lives in the Cloud and has a dual role to a service worker in the browser. It mediates network requests from anywhere in the Internet that target one device or app instance.

Each RSW has an stable URL that provides a public name for the endpoint, some private state, a set of methods that can be called remotely, and a managed security policy that restricts who can call them.

RSWs are implemented with a **cloud assistant**, following the Actor Model, and thousands of them can run on one node.js process.

RSWs have two modes of operation:

##### 1. Pass-through mode

An endpoint, for example, a device or app instance, connects to an RSW using a web socket. The RSW receives API requests from the Internet, performs security checks, updates its state, and then notifies the connected endpoint, or other clients connected with web sockets. These notifications can then trigger actions in the physical world, or keep other user interfaces in sync.

Any Internet client with proper credentials can now, in real-time, trigger device actions or read its data. But clients never have direct access, credentials are short-lived signed tokens (JWT), access policy is centrally managed and consistent for all your devices, and, more importantly, the interface could just expose the minimal functionality required by your app.


##### 2. Impersonation mode

What happens when the endpoint is not connected? The RSW **pretends** to be the endpoint, making decisions on its behalf based on local state, and helping the rest of the world to move forward.

RSWs typically implement both modes, switching between them based on endpoint connectivity. For example, it could start in impersonation mode, negotiate some actions, and then relay those actions in pass-through mode when the endpoint eventually connects.

What if local device actions, taken while offline, are incompatible with actions proposed by the RSW? The answer is very application dependent, but a simple approach is to route actions through the RSW, and only perform emergency local actions when offline.

#### Three-way Isomorphic

What is really an endpoint? In most cases we are not going to modify the firmware of a simple device, or patch an existing application. Instead, we write bridging code, also in JavaScript, that will interface locally with the real endpoint over Bluetooth or other protocol.

Therefore, most applications in **Caf.js** are made of three JavaScript programs, i.e., front-end, cloud, and device bridging code.

The advantage of **Caf.js** is that these three programs are all developed, debugged, and deployed as a single unit. They also share many software components. In fact, using our CLI tools, you can emulate in a laptop both the Cloud and the device. And then, trace a request from the browser, to the emulated Cloud, and finally to the emulated device, all without leaving the Chrome web developer tools.

But that's not all. **Caf.js** is a **three-way isomorphic** framework. The device bridging code runs in a Raspberry Pi, but it can also run in a browser, and in the Cloud too.

And that opens many doors. You don't need to carry a Raspberry Pi or a laptop. Your phone, with a browser that supports the Web Bluetooth API, such as Chrome for Android, can also bridge Bluetooth devices.

Some applications will still require a  dedicated bridging device, but many will benefit from the convenience of the phone. And for Android phones is even better, the default browser is all you need!

What about running bridging code in the Cloud? Three important benefits:

* Simplifies endpoint impersonation for RSWs.
* Enables realistic load testing by emulating thousands of devices in the Cloud.
* Dynamically creates user interfaces by introspecting the bridging code.

and all this isomorphic magic relies on standard tools, such as *browserify*.
